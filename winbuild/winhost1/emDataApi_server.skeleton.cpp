// This autogenerated skeleton file illustrates how to build a server.
// You should copy it to another filename to avoid overwriting it.

#include "emDataApi.h"
#include <thrift/protocol/TBinaryProtocol.h>
#include <thrift/server/TSimpleServer.h>
#include <thrift/transport/TServerSocket.h>
#include <thrift/transport/TBufferTransports.h>

using namespace ::apache::thrift;
using namespace ::apache::thrift::protocol;
using namespace ::apache::thrift::transport;
using namespace ::apache::thrift::server;

using boost::shared_ptr;

using namespace  ::emInterfaces;

class emDataApiHandler : virtual public emDataApiIf {
 public:
  emDataApiHandler() {
    // Your initialization goes here
  }

  void createBuffer(std::string& _return, const int64_t length) {
    // Your implementation goes here
    printf("createBuffer\n");
  }

  void destroyBuffer(const std::string& bufferName) {
    // Your implementation goes here
    printf("destroyBuffer\n");
  }

  void getBuffer(emWaveForm& _return, const std::string& bufferName) {
    // Your implementation goes here
    printf("getBuffer\n");
  }

  void setBuffer(std::string& _return, const emWaveForm& samples) {
    // Your implementation goes here
    printf("setBuffer\n");
  }

  void cloneBuffer(std::string& _return, const std::string& bufferName) {
    // Your implementation goes here
    printf("cloneBuffer\n");
  }

  void renameBuffer(const std::string& oldBufferName, const std::string& newBufferName) {
    // Your implementation goes here
    printf("renameBuffer\n");
  }

  void saveBuffer(const std::string& bufferName, const std::string& fileName) {
    // Your implementation goes here
    printf("saveBuffer\n");
  }

  void loadBuffer(std::string& _return, const std::string& fileName) {
    // Your implementation goes here
    printf("loadBuffer\n");
  }

  void absDifference(std::string& _return, const std::string& bufferA, const std::string& bufferB) {
    // Your implementation goes here
    printf("absDifference\n");
  }

  double sum(const std::string& bufferName) {
    // Your implementation goes here
    printf("sum\n");
  }

  double sumSquaredDifference(const std::string& bufferA, const std::string& bufferB) {
    // Your implementation goes here
    printf("sumSquaredDifference\n");
  }

  void subtract(std::string& _return, const std::string& bufferA, const std::string& bufferB) {
    // Your implementation goes here
    printf("subtract\n");
  }

  void add(std::string& _return, const std::string& bufferA, const std::string& bufferB) {
    // Your implementation goes here
    printf("add\n");
  }

  void setValues(const std::string& bufferName, const int32_t value) {
    // Your implementation goes here
    printf("setValues\n");
  }

  void threshold(std::string& _return, const std::string& bufferName, const int32_t thresholdValue, const int32_t maxValue, const bool invert) {
    // Your implementation goes here
    printf("threshold\n");
  }

  void normalize(std::string& _return, const std::string& bufferName, const int32_t minValue, const int32_t maxValue) {
    // Your implementation goes here
    printf("normalize\n");
  }

  void quantize(std::string& _return, const std::string& bufferName, const int32_t minValue, const int32_t maxValue, const int32_t levels) {
    // Your implementation goes here
    printf("quantize\n");
  }

  void resample(std::string& _return, const std::string& bufferName, const int32_t newLength) {
    // Your implementation goes here
    printf("resample\n");
  }

  void medianFilter(std::string& _return, const std::string& bufferName, const int32_t fitlerSize) {
    // Your implementation goes here
    printf("medianFilter\n");
  }

};

int main(int argc, char **argv) {
  int port = 9090;
  shared_ptr<emDataApiHandler> handler(new emDataApiHandler());
  shared_ptr<TProcessor> processor(new emDataApiProcessor(handler));
  shared_ptr<TServerTransport> serverTransport(new TServerSocket(port));
  shared_ptr<TTransportFactory> transportFactory(new TBufferedTransportFactory());
  shared_ptr<TProtocolFactory> protocolFactory(new TBinaryProtocolFactory());

  TSimpleServer server(processor, serverTransport, transportFactory, protocolFactory);
  server.serve();
  return 0;
}

