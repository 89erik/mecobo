// This autogenerated skeleton file illustrates how to build a server.
// You should copy it to another filename to avoid overwriting it.

#include "emEvolvableMotherboard.h"
#include <thrift/protocol/TBinaryProtocol.h>
#include <thrift/server/TSimpleServer.h>
#include <thrift/transport/TServerSocket.h>
#include <thrift/transport/TBufferTransports.h>

#include "mecohost.h"
#include "../mecoprot.h"
#include <map>
#include <queue>
#include <thread>

using namespace ::apache::thrift;
using namespace ::apache::thrift::protocol;
using namespace ::apache::thrift::transport;
using namespace ::apache::thrift::server;

using boost::shared_ptr;

using namespace  ::emInterfaces;

class emEvolvableMotherboardHandler : virtual public emEvolvableMotherboardIf {

  std::thread runThread;

  int64_t time;
  std::map<int, std::queue<emSequenceItem>> pinSeq;
  std::map<int, std::vector<uint32_t>> rec;
  //std::vector<int> recPins;

  public:
  emEvolvableMotherboardHandler() {
    // Your initialization goes here
    time = 0;
  }

  int32_t ping() {
    // Your implementation goes here
    printf("ping\n");
  }

  void setLED(const int32_t index, const bool state) {
    // Your implementation goes here
    printf("setLED\n");
  }

  void getMotherboardID(std::string& _return) {
    // Your implementation goes here
    printf("getMotherboardID\n");
  }

  void getMotherboardState(std::string& _return) {
    // Your implementation goes here
    printf("getMotherboardState\n");
  }

  void getLastError(std::string& _return) {
    // Your implementation goes here
    printf("getLastError\n");
  }

  bool reset() {
    // Your implementation goes here
    printf("reset\n");
  }

  bool reprogramme(const std::string& bin, const int32_t length) {
    // Your implementation goes here
    printf("reprogramme\n");
  }

  void getDebugState(emDebugInfo& _return) {
    // Your implementation goes here
    printf("getDebugState\n");
  }

  void clearSequences() {
    // Your implementation goes here
    printf("clearSequences\n");
    //seq.clear();
  }

  void runSequences() {
   
    auto start = std::chrono::system_clock::now();
    int64_t t = 0;
    bool done = false;
    for(auto p : rec) {
      p.second.clear();
    }

    while(!done) {

      //Iterate all the queues, check if it's time to do a sequence action.
      for(auto k : pinSeq) {
        //Peek queue
        if(pinSeq[k.first].size() > 0) {
          auto item = pinSeq[k.first].front();
          auto now = std::chrono::system_clock::now();

          if(item.startTime <= std::chrono::duration_cast<std::chrono::milliseconds>(now - start).count()) {
            std::cout << "Playing item on pin " << k.first << " at time " << t << "scheduled at" << item.startTime << std::endl;
            std::cout << "seqitem, f:" << item.frequency << "optype:" << item.operationType << std::endl;
            double period; //= 1.0f/(double)s.frequency;
            int32_t duty; // = period * (25*1000000);
            uint32_t sampleDiv = ((50*1000000)/(8.0f*(double)item.frequency));
            emException err;
            switch(item.operationType) {
              case emSequenceOperationType::type::CONST:
                if(item.waveFormType == emWaveFormType::PWM) {
                  setPin((FPGA_IO_Pins_TypeDef)item.pin, item.amplitude, 0, 0x1, 0x0);
                  startOutput((FPGA_IO_Pins_TypeDef)item.pin);
                }
                break;
              case emSequenceOperationType::type::PREDEFINED:
                //Since it's predefined, we have a waveFormType
                if(item.waveFormType == emWaveFormType::PWM) {

                  period = 1.0f/(double)item.frequency;
                  duty = period * (25*1000000);
                  std::cout << "duty:" << duty << std::endl;
                  
                  setPin((FPGA_IO_Pins_TypeDef)item.pin, duty, duty * (100.0f/item.cycleTime), 0x1, 0x0);
                  startOutput((FPGA_IO_Pins_TypeDef)item.pin);
                }
                break;
              case emSequenceOperationType::type::RECORD:
                std::cout << "samplediv:" << sampleDiv << std::endl;
                if(sampleDiv < 8) {
                  err.Reason = "samplerate too high";
                  err.Source = "emMotherboard";
                  throw err;
                  break;
                } else if (sampleDiv > 65535) {
                  err.Reason = "samplerate too low";
                  err.Source = "emMotherboard";
                  throw err;
                  break;
                }
                setPin((FPGA_IO_Pins_TypeDef)item.pin, 1, 1, 1, sampleDiv);
                startInput((FPGA_IO_Pins_TypeDef)item.pin);
                break;
              default:
                break;
            }
            pinSeq[k.first].pop(); //remove element from queue.
          }
        }
      }

      //Poke the board for sample buffers for the 
      //pins that we have selected for recording.
      std::vector<sampleValue> samples;
      getSampleBuffer(samples);
      for(auto s : samples) {
        rec[s.pin].push_back(s.value);
      }


      //Check if queues are empty.
      done = true;
      for(auto q : pinSeq) {
        if(q.second.size() > 0) {
          done = false;
        }
      }
    }
    std::cout << "Sequence done, all qeueues empty" << std::endl;
  } 


  void stopSequences() {
    // Your implementation goes here
    printf("stopSequences\n");
  }

  void joinSequences() {
    // Your implementation goes here
    printf("joinSequences\n");
  }

  void appendSequenceAction(const emSequenceItem& Item) {
    //TODO: Lots of error checking and all that jazzy.
    std::cout << "Appending action" << std::endl;
    pinSeq[Item.pin].push(Item);
  }

  void getRecording(emWaveForm& _return, const int32_t srcPin) {
    // Your implementation goes here
    std::vector<int32_t> v;
    std::vector<sampleValue> samples;

    std::cout << "There are " << rec[srcPin].size() << "samples for pin " << srcPin << std::endl;
    for(auto s : rec[srcPin]) {
      //std::cout << s.sampleNum << std::endl;
      v.push_back(s);
    }

    emWaveForm r;
    r.SampleCount = v.size();
    r.Samples = v;
    _return = r;

    rec[srcPin].clear();
  }


  void clearRecording(const int32_t srcPin) {
    // Your implementation goes here
    printf("clearRecording\n");
  }

  int32_t getTemperature() {
    // Your implementation goes here
    printf("getTemperature\n");
  }

  void setLogServer(const emLogServerSettings& logServer) {
    // Your implementation goes here
    printf("setLogServer\n");
  }

};

int main(int argc, char **argv) {

  uint32_t progFpga = 0;
  //Command line arguments
  if (argc > 1) {
    for(int i = 0; i < argc; i++) {
      if(strcmp(argv[i], "-f") == 0) {
        progFpga = 1;
      }
    }
  }
  if(progFpga) 
    programFPGA("mecobo.bin");



  int port = 9090;

  std::cout << "Starting USB..." << std::endl;
  startUsb();
  std::cout << "Done!" << std::endl;

  shared_ptr<emEvolvableMotherboardHandler> handler(new emEvolvableMotherboardHandler());
  shared_ptr<TProcessor> processor(new emEvolvableMotherboardProcessor(handler));
  shared_ptr<TServerTransport> serverTransport(new TServerSocket(port));
  shared_ptr<TTransportFactory> transportFactory(new TBufferedTransportFactory());
  shared_ptr<TProtocolFactory> protocolFactory(new TBinaryProtocolFactory());

  TSimpleServer server(processor, serverTransport, transportFactory, protocolFactory);

  std::cout << "Starting thrift server. (Silence ensues)." << std::endl;
  server.serve();

  std::cout << "Stopping USB..." << std::endl;
  stopUsb();
  std::cout << "Done!" << std::endl;

  return 0;
}

