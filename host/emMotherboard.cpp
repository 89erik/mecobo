// This autogenerated skeleton file illustrates how to build a server.
// You should copy it to another filename to avoid overwriting it.

#include "emEvolvableMotherboard.h"
#include <thrift/protocol/TBinaryProtocol.h>
#include <thrift/server/TSimpleServer.h>
#include <thrift/transport/TServerSocket.h>
#include <thrift/transport/TBufferTransports.h>

#include "mecohost.h"
#include "../uc/mecoprot.h"


using namespace ::apache::thrift;
using namespace ::apache::thrift::protocol;
using namespace ::apache::thrift::transport;
using namespace ::apache::thrift::server;

using boost::shared_ptr;

using namespace  ::emInterfaces;

class emEvolvableMotherboardHandler : virtual public emEvolvableMotherboardIf {

  std::vector<emSequenceItem> seq;

 public:
  emEvolvableMotherboardHandler() {
    // Your initialization goes here
  }

  int32_t ping() {
    // Your implementation goes here
    printf("ping\n");
  }

  void getMotherboardID(std::string& _return) {
    // Your implementation goes here
    printf("getMotherboardID\n");
  }

  void waitUntilReady() {
    // Your implementation goes here
    printf("waitUntilReady\n");
  }

  void getMotherboardState(std::string& _return) {
    // Your implementation goes here
    printf("getMotherboardState\n");
  }

  void getLastError(std::string& _return) {
    // Your implementation goes here
    printf("getLastError\n");
  }

  bool reset() {
    // Your implementation goes here
    printf("reset\n");
  }

  void clearSequences() {
    // Your implementation goes here
    printf("clearSequences\n");
    seq.clear();
  }

  void runSequences() {

    // The application-clock runs at 50MHz. 
    // Thus, to get a 10MHz signal, you 
    // take 1/freq * (50*10^6) to get the duty.

    for(auto s : seq) {
      std::cout << "seqitem, f:" << s.frequency << "optype:" << s.operationType << std::endl;
      double period = 1.0f/(double)s.frequency;
      int32_t duty = period * (25*1000000);
      std::cout << "duty:" << duty << std::endl;

      uint32_t sampleDiv = ((50*1000000)/(8.0f*(double)s.frequency));
      emException err;
      switch(s.operationType) {
        case emSequenceOperationType::type::PWM:
          setPin(FPGA_F16, duty, duty, 0x1, 0x0);
          startOutput(FPGA_F16);
          break;
        case emSequenceOperationType::type::RECORD:
          std::cout << "samplediv:" << sampleDiv << std::endl;
          if(sampleDiv < 8) {
            err.Reason = "samplerate too high";
            err.Source = "emMotherboard";
            throw err;
            break;
          } else if (sampleDiv > 65535) {
            err.Reason = "samplerate too low";
            err.Source = "emMotherboard";
            throw err;
            break;
          }

          setPin(FPGA_J16, 1, 1, 1, sampleDiv);
          startInput(FPGA_J16);
          break;
        default:
          break;
      }
    }
    seq.clear();
    std::cout << "sequence size after clear:" << seq.size() << std::endl;
  }

  void stopSequences() {
    // Your implementation goes here
    printf("stopSequences\n");
  }

  void joinSequence() {
    // Your implementation goes here
    printf("joinSequence\n");
  }

  void appendSequenceAction(const emSequenceItem& Item) {
    // Your implementation goes here
    seq.push_back(Item);
    std::cout << "sequence size after append:" << seq.size() << std::endl;
  }

  void getRecording(emWaveForm& _return, const int32_t srcPin) {
    // Your implementation goes here
    std::vector<int32_t> v;
    std::vector<sampleValue> samples;

    getSampleBuffer(samples);
    for(auto s : samples) {
      //std::cout << s.sampleNum << std::endl;
      v.push_back(s.value);
    }

    emWaveForm r;
    r.SampleCount = v.size();
    r.Samples = v;
    _return = r;
  }

  void clearRecording(const int32_t srcPin) {
    // Your implementation goes here
    printf("clearRecording\n");
  }

  void setBaseRate(const int32_t rate) {
    // Your implementation goes here
    printf("setBaseRate\n");
  }

  int64_t getTime() {
    // Your implementation goes here
    printf("getTime\n");
  }

  int32_t getTemperate() {
    // Your implementation goes here
    printf("getTemperate\n");
  }

  int32_t getVoltage() {
    // Your implementation goes here
    printf("getVoltage\n");
  }

  void setLogServer(const emLogServerSettings& logServer) {
    // Your implementation goes here
    printf("setLogServer\n");
  }

};

int main(int argc, char **argv) {

  uint32_t progFpga = 0;
  //Command line arguments
  if (argc > 1) {
    for(int i = 0; i < argc; i++) {
      if(strcmp(argv[i], "-f") == 0) {
          progFpga = 1;
      }
    }
 }
    if(progFpga) 
    programFPGA("mecobo.bin");

  int port = 9090;

  startUsb();
  shared_ptr<emEvolvableMotherboardHandler> handler(new emEvolvableMotherboardHandler());
  shared_ptr<TProcessor> processor(new emEvolvableMotherboardProcessor(handler));
  shared_ptr<TServerTransport> serverTransport(new TServerSocket(port));
  shared_ptr<TTransportFactory> transportFactory(new TBufferedTransportFactory());
  shared_ptr<TProtocolFactory> protocolFactory(new TBinaryProtocolFactory());

  TSimpleServer server(processor, serverTransport, transportFactory, protocolFactory);
  server.serve();

  stopUsb();
  return 0;
}

