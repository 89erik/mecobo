/**
 * Autogenerated by Thrift Compiler (0.9.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
using System;
using System.Collections;
using System.Collections.Generic;
using System.Text;
using System.IO;
using Thrift;
using Thrift.Collections;
using System.Runtime.Serialization;
using Thrift.Protocol;
using Thrift.Transport;

namespace emInterfaces
{

  /// <summary>
  /// Definition of an operation to be performed. Not all parameters may be used. It will depend on the operationType. If something can't be performed by the EM, exceptions should be thrown when adding to the buffers. Timings are defined by FPGA ticks, which will need to be converted to Hz.
  /// </summary>
  #if !SILVERLIGHT
  [Serializable]
  #endif
  public partial class emSequenceItem : TBase
  {
    private emSequenceOperationType _operationType;
    private List<int> _pin;
    private long _startTime;
    private long _endTime;
    private int _frequency;
    private int _phase;
    private int _cycleTime;
    private int _amplitude;
    private emWaveFormType _waveFormType;
    private emWaveForm _waveForm;
    private int _waitForTrigger;

    /// <summary>
    /// What the action is
    /// 
    /// <seealso cref="emSequenceOperationType"/>
    /// </summary>
    public emSequenceOperationType OperationType
    {
      get
      {
        return _operationType;
      }
      set
      {
        __isset.operationType = true;
        this._operationType = value;
      }
    }

    /// <summary>
    /// Where the action is applied to, as a list of connections to the material
    /// </summary>
    public List<int> Pin
    {
      get
      {
        return _pin;
      }
      set
      {
        __isset.pin = true;
        this._pin = value;
      }
    }

    /// <summary>
    /// Ticks it should start at
    /// </summary>
    public long StartTime
    {
      get
      {
        return _startTime;
      }
      set
      {
        __isset.startTime = true;
        this._startTime = value;
      }
    }

    /// <summary>
    /// Ticks it should end at
    /// </summary>
    public long EndTime
    {
      get
      {
        return _endTime;
      }
      set
      {
        __isset.endTime = true;
        this._endTime = value;
      }
    }

    /// <summary>
    /// Definition of signal, if appropriate
    /// </summary>
    public int Frequency
    {
      get
      {
        return _frequency;
      }
      set
      {
        __isset.frequency = true;
        this._frequency = value;
      }
    }

    public int Phase
    {
      get
      {
        return _phase;
      }
      set
      {
        __isset.phase = true;
        this._phase = value;
      }
    }

    public int CycleTime
    {
      get
      {
        return _cycleTime;
      }
      set
      {
        __isset.cycleTime = true;
        this._cycleTime = value;
      }
    }

    public int Amplitude
    {
      get
      {
        return _amplitude;
      }
      set
      {
        __isset.amplitude = true;
        this._amplitude = value;
      }
    }

    /// <summary>
    /// Predefined wave form, eg. square, sawtooth, sine
    /// 
    /// <seealso cref="emWaveFormType"/>
    /// </summary>
    public emWaveFormType WaveFormType
    {
      get
      {
        return _waveFormType;
      }
      set
      {
        __isset.waveFormType = true;
        this._waveFormType = value;
      }
    }

    /// <summary>
    /// If playing back an arbitrary signal, buffer is attached here
    /// </summary>
    public emWaveForm WaveForm
    {
      get
      {
        return _waveForm;
      }
      set
      {
        __isset.waveForm = true;
        this._waveForm = value;
      }
    }

    /// <summary>
    /// If >=0 wait for a trigger on certain pin before running
    /// </summary>
    public int WaitForTrigger
    {
      get
      {
        return _waitForTrigger;
      }
      set
      {
        __isset.waitForTrigger = true;
        this._waitForTrigger = value;
      }
    }


    public Isset __isset;
    #if !SILVERLIGHT
    [Serializable]
    #endif
    public struct Isset {
      public bool operationType;
      public bool pin;
      public bool startTime;
      public bool endTime;
      public bool frequency;
      public bool phase;
      public bool cycleTime;
      public bool amplitude;
      public bool waveFormType;
      public bool waveForm;
      public bool waitForTrigger;
    }

    public emSequenceItem() {
      this._frequency = 0;
      this._phase = 0;
      this._cycleTime = 0;
      this._amplitude = 0;
      this._waitForTrigger = -1;
    }

    public void Read (TProtocol iprot)
    {
      TField field;
      iprot.ReadStructBegin();
      while (true)
      {
        field = iprot.ReadFieldBegin();
        if (field.Type == TType.Stop) { 
          break;
        }
        switch (field.ID)
        {
          case 1:
            if (field.Type == TType.I32) {
              OperationType = (emSequenceOperationType)iprot.ReadI32();
            } else { 
              TProtocolUtil.Skip(iprot, field.Type);
            }
            break;
          case 2:
            if (field.Type == TType.List) {
              {
                Pin = new List<int>();
                TList _list4 = iprot.ReadListBegin();
                for( int _i5 = 0; _i5 < _list4.Count; ++_i5)
                {
                  int _elem6 = 0;
                  _elem6 = iprot.ReadI32();
                  Pin.Add(_elem6);
                }
                iprot.ReadListEnd();
              }
            } else { 
              TProtocolUtil.Skip(iprot, field.Type);
            }
            break;
          case 3:
            if (field.Type == TType.I64) {
              StartTime = iprot.ReadI64();
            } else { 
              TProtocolUtil.Skip(iprot, field.Type);
            }
            break;
          case 4:
            if (field.Type == TType.I64) {
              EndTime = iprot.ReadI64();
            } else { 
              TProtocolUtil.Skip(iprot, field.Type);
            }
            break;
          case 5:
            if (field.Type == TType.I32) {
              Frequency = iprot.ReadI32();
            } else { 
              TProtocolUtil.Skip(iprot, field.Type);
            }
            break;
          case 6:
            if (field.Type == TType.I32) {
              Phase = iprot.ReadI32();
            } else { 
              TProtocolUtil.Skip(iprot, field.Type);
            }
            break;
          case 7:
            if (field.Type == TType.I32) {
              CycleTime = iprot.ReadI32();
            } else { 
              TProtocolUtil.Skip(iprot, field.Type);
            }
            break;
          case 8:
            if (field.Type == TType.I32) {
              Amplitude = iprot.ReadI32();
            } else { 
              TProtocolUtil.Skip(iprot, field.Type);
            }
            break;
          case 9:
            if (field.Type == TType.I32) {
              WaveFormType = (emWaveFormType)iprot.ReadI32();
            } else { 
              TProtocolUtil.Skip(iprot, field.Type);
            }
            break;
          case 10:
            if (field.Type == TType.Struct) {
              WaveForm = new emWaveForm();
              WaveForm.Read(iprot);
            } else { 
              TProtocolUtil.Skip(iprot, field.Type);
            }
            break;
          case 11:
            if (field.Type == TType.I32) {
              WaitForTrigger = iprot.ReadI32();
            } else { 
              TProtocolUtil.Skip(iprot, field.Type);
            }
            break;
          default: 
            TProtocolUtil.Skip(iprot, field.Type);
            break;
        }
        iprot.ReadFieldEnd();
      }
      iprot.ReadStructEnd();
    }

    public void Write(TProtocol oprot) {
      TStruct struc = new TStruct("emSequenceItem");
      oprot.WriteStructBegin(struc);
      TField field = new TField();
      if (__isset.operationType) {
        field.Name = "operationType";
        field.Type = TType.I32;
        field.ID = 1;
        oprot.WriteFieldBegin(field);
        oprot.WriteI32((int)OperationType);
        oprot.WriteFieldEnd();
      }
      if (Pin != null && __isset.pin) {
        field.Name = "pin";
        field.Type = TType.List;
        field.ID = 2;
        oprot.WriteFieldBegin(field);
        {
          oprot.WriteListBegin(new TList(TType.I32, Pin.Count));
          foreach (int _iter7 in Pin)
          {
            oprot.WriteI32(_iter7);
          }
          oprot.WriteListEnd();
        }
        oprot.WriteFieldEnd();
      }
      if (__isset.startTime) {
        field.Name = "startTime";
        field.Type = TType.I64;
        field.ID = 3;
        oprot.WriteFieldBegin(field);
        oprot.WriteI64(StartTime);
        oprot.WriteFieldEnd();
      }
      if (__isset.endTime) {
        field.Name = "endTime";
        field.Type = TType.I64;
        field.ID = 4;
        oprot.WriteFieldBegin(field);
        oprot.WriteI64(EndTime);
        oprot.WriteFieldEnd();
      }
      if (__isset.frequency) {
        field.Name = "frequency";
        field.Type = TType.I32;
        field.ID = 5;
        oprot.WriteFieldBegin(field);
        oprot.WriteI32(Frequency);
        oprot.WriteFieldEnd();
      }
      if (__isset.phase) {
        field.Name = "phase";
        field.Type = TType.I32;
        field.ID = 6;
        oprot.WriteFieldBegin(field);
        oprot.WriteI32(Phase);
        oprot.WriteFieldEnd();
      }
      if (__isset.cycleTime) {
        field.Name = "cycleTime";
        field.Type = TType.I32;
        field.ID = 7;
        oprot.WriteFieldBegin(field);
        oprot.WriteI32(CycleTime);
        oprot.WriteFieldEnd();
      }
      if (__isset.amplitude) {
        field.Name = "amplitude";
        field.Type = TType.I32;
        field.ID = 8;
        oprot.WriteFieldBegin(field);
        oprot.WriteI32(Amplitude);
        oprot.WriteFieldEnd();
      }
      if (__isset.waveFormType) {
        field.Name = "waveFormType";
        field.Type = TType.I32;
        field.ID = 9;
        oprot.WriteFieldBegin(field);
        oprot.WriteI32((int)WaveFormType);
        oprot.WriteFieldEnd();
      }
      if (WaveForm != null && __isset.waveForm) {
        field.Name = "waveForm";
        field.Type = TType.Struct;
        field.ID = 10;
        oprot.WriteFieldBegin(field);
        WaveForm.Write(oprot);
        oprot.WriteFieldEnd();
      }
      if (__isset.waitForTrigger) {
        field.Name = "waitForTrigger";
        field.Type = TType.I32;
        field.ID = 11;
        oprot.WriteFieldBegin(field);
        oprot.WriteI32(WaitForTrigger);
        oprot.WriteFieldEnd();
      }
      oprot.WriteFieldStop();
      oprot.WriteStructEnd();
    }

    public override string ToString() {
      StringBuilder sb = new StringBuilder("emSequenceItem(");
      sb.Append("OperationType: ");
      sb.Append(OperationType);
      sb.Append(",Pin: ");
      sb.Append(Pin);
      sb.Append(",StartTime: ");
      sb.Append(StartTime);
      sb.Append(",EndTime: ");
      sb.Append(EndTime);
      sb.Append(",Frequency: ");
      sb.Append(Frequency);
      sb.Append(",Phase: ");
      sb.Append(Phase);
      sb.Append(",CycleTime: ");
      sb.Append(CycleTime);
      sb.Append(",Amplitude: ");
      sb.Append(Amplitude);
      sb.Append(",WaveFormType: ");
      sb.Append(WaveFormType);
      sb.Append(",WaveForm: ");
      sb.Append(WaveForm== null ? "<null>" : WaveForm.ToString());
      sb.Append(",WaitForTrigger: ");
      sb.Append(WaitForTrigger);
      sb.Append(")");
      return sb.ToString();
    }

  }

}
